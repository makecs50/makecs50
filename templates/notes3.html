---
layout: header
title: Note3
permalink: /weeks/notes3
---

<div class="toc2 toc-left">
            <div id="header">
                <div class="toc2" id="toc">
                    <div id="toctitle">Список Контента</div>
                    <ul class="sectlevel1">
<li><a href="#last-time">В прошлый раз</a></li>
<li><a href="#sorting">Сортировка</a></li>
<li><a href="#running-time">Время выполнения работы</a></li>
<li><a href="#sorting-2">Сортировка</a></li>
</ul>
                </div>
            </div>
            <div id="content">
                <h1>Неделя 3</h1>
<div class="sect1">
<h2 id="last-time"><a class="link" href="#last-time">В прошлый раз</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Мы познакомились с искусством поиска ошибок (дебаггингом или отладкой) и нашими помощниками в этом деле были: <code>eprintf</code> - выводит ошибки на экран; <code>debug50</code> - помогает просматривать, что происходит на каждом шаге выполнения программы и показывает изменения переменных.</p>
</li>
<li>
<p>Мы также разобрали понятие криптографии и то, как можно зашифровать простой текст.</p>
</li>
<li>
<p>Теперь мы лучше понимаем, что такое strings (строки) и массив символов.</p>
</li>
<li>
<p>Мы разобрали аргументы командной строки, используя <code>argc</code> и <code>argv</code> через командную строку для их дальнейшего применения в функции <code>main</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sorting"><a class="link" href="#sorting">Сортировка</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Теперь, разобрав основы программирования, мы можем перейти к "решению проблем", используя алгоритмы на более высоком уровне.</p>
</li>
<li>
<p>Массив - это структура данных, способ хранения информации в памяти.</p>
</li>
<li>
<p>Представьте, что перед вами 7 дверей, и вам нужно найти определенное число, которое находится за одной из них.</p>
</li>
<li>
<p>Не имея никакого представления, где может находиться данное число, вы начнете наугад (случайным образом или random) открывать каждую дверь.</p>
</li>
<li>
<p>Но если бы мы знали, что числа, находящиеся за этими дверями отсортированы, мы могли бы выполнить задачу намного эффективнее.</p>
</li>
<li>
<p>Точно также как и на нулевой неделе, когда мы с каждым шагом отбрасывали половину проблемы (пример с телефонным справочником), мы можем осуществлять поиск в сортированном массиве, используя бинарный поиск. Открыв одну дверь и увидев значение, проверять больше оно или меньше необходимого нам числа. А затем продвигаться к той половине, в которой возможно есть нужное нам значение.</p>
</li>
<li>
<p>Другой вид поискового алгоритма - линейный поиск (последовательный поиск), продвижение по линии слева направо. Можно написать псевдокод (слова похожие на код, но намного более легкие для понимания) следующим образом:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>Для каждого элемента в массиве
    Если нужный элемент
        вернуть истину
вернуть ложь</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Заметьте, что <code>вернуть ложь</code> находится за пределами цикла <code>for</code>. Другими словами, дойдя до конца цикла (при условии что вы разобрали каждый элемент, находящийся в массиве, и не смогли найти именно тот, что нам нужен) - мы можем с полной увереностью сказать, что его там нету (или <code>вернуть ложь</code>).</p>
<div class="ulist">
<ul>
<li>
<p>Обратите внимание на отступы в написании нашего псевдокода, так мы указываем иерархию каждой строки псевдокода. К примеру выражение <code>вернуть ложь</code> выполнится только после того, как весь цикл <code>for</code> завершит свою работу. В противном случае, если мы неправильно укажем отступы и строка окажется внутри цикла, проверке подвергнется только первый элемент массива.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Бинарный поиск нулевой недели используя псевдокод можно записать следующим образом:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>посмотреть в центр массива
Если нужный элемент
    вернуть истину
иначе если элемент слева
    искать левую половину массива
иначе если элемент справа
    искать правую половину массива
иначе
    вернуть ложь</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Теперь мы работаем с непронумерованными строками, к которым можно было бы возвращаться для повторных действий. Но обратите внимание, <code>искать левую половину массива</code> и <code>искать правую половину массива</code> - могут по новой запустить выполнение всего алгоритма. Мы используем тот же самый метод поиска, но на этот раз данные на входе будут каждый раз становиться все меньше и меньше, пока в конце концов мы не доберемся до ответа. Функция, вызывающая саму себя, называется рекурсивной функцией, и этот принцип рекурсии играет важную роль при поиске и сортировке каких-либо элементов.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Так как же нам получить отсортированный массив? У нас есть доброволец Аллисон - она занимается сортировкой неких синих книг. Каждый раз она забирает левой рукой книгу из неотсортированной стопки и кладет ее в нужное место отсортированной стопки, которое находит при помощи правой руки.
</p>
</li>
<li>
<p>Если бы у нас были игральные карты, мы могли бы взять коробочки и расположить в них карты по числу или по масти (пики, червы, бубны и трефы). Взяв несколько колод карт, мы можем пройтись и отсортировать их.</p>
</li>
<li>
<p>Можно представить эту проблему, подставив числа вместо элементов:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>4 2 6 8 1 3 7 5</code></pre>
</div>
</div>
</li>
<li>
<p>Первый подход - поиск наименьшего элемента <code>1</code> и его передвижение в начальную часть списка с перемещением других ниже (правее) по списку:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><u>1</u> <u>4 2 6 8</u> 3 7 5</code></pre>
</div>
</div>
</li>
<li>
<p>Можно продолжить:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>1 <u>2</u> <u>4 6 8</u> 3 7 5
1 2 <u>3</u> <u>4 6 8</u> 7 5
1 2 3 4 <u>5</u> <u>6 8 7</u>
1 2 3 4 5 6 <u>7</u> <u>8</u></code></pre>
</div>
</div>
</li>
<li>
<p>В нашем первом шаге нам понадобилось проделать много работы, перемещая все числа, находящиеся слева от <code>1</code>, в правую сторону от нее. Мы можем просто поменять местами <code>1</code> и первое число:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>4 2 6 8 1 3 7 5
<u>1</u> 2 6 8 <u>4</u> 3 7 5
1 2 <u>3</u> 8 4 <u>6</u> 7 5
...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Теперь каждый шаг требует от нас затраты меньшего количества времени.</p>
</li>
<li>
<p>Но, чтобы каждый раз выбирать элемент с наименьшим значением, нам нужно пройтись по всей неотсортированной части нашего списка для того, чтобы убедиться, что будет выбран именно самый наименьший из них - так мы будем знать, какие элементы мы можем поменять местами.</p>
</li>
<li>
<p>Этот алгоритм называют <strong>сортировка выбором</strong> (selection sort), где каждый раз мы выбираем наименьший элемент.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Есть еще один способ - <strong>пузырьковая сортировка</strong> (bubble sort):</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>4 2 6 8 1 3 7 5
<u>2</u> <u>4</u> 6 8 1 3 7 5
2 4 6 <u>1</u> <u>8</u> 3 7 5
2 4 6 1 <u>3</u> <u>8</u> 7 5
2 4 6 1 3 <u>7</u> <u>8</u> 5
2 4 6 1 3 7 <u>5</u> <u>8</u></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Мы проходим по всему списку слева направо и сравниваем каждую пару номеров. Если они расположены не по порядку - мы меняем их местами. Список еще не отсортирован, но число с наибольшим значением теперь находится справа и остальные цифры стали немного ближе к местам, где они должны располагаться.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Мы можем повторять этот процесс снова и снова, пока не получим отсортированный список. Наш алгоритм остановится в тот момент, когда мы пройдем по всему списку и не совершим ни одного перемещения.</p>
</li>
<li>
<p>И, наконец, последний подход, который мы разберем, называется <strong>сортировка вставками</strong> (insertion sort). Мы рассмотрим по отдельности каждый элемент и заодно создадим наш сортированный список:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><u>4</u> 2 6 8 1 3 7 5
<u>2 4</u> 6 8 1 3 7 5
<u>1 2 4 6 8</u> 3 7 5
<u>1 2 3 4 6 8</u> 7 5
<u>1 2 3 4 5 6 8</u> 7
<u>1 2 3 4 5 6 7 8</u></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Мы смотрим на следующий элемент и помещаем его в нашу сортированную часть списка, даже если нам и придется каждый раз сдвигать все элементы.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-time"><a class="link" href="#running-time">Время выполнения работы</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Наш алгоритм пузырьковой сортировки может выглядеть как-то так:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>повторять, пока не закончатся смещения
    для i от 0 до n-2
        если i'ый и i+1'ый элементы не идут по порядку
            поменять их местами</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Помните, что элемент в конце списка представляется следующим образом <code>n - 1</code>, т.к. мы начинаем считать от <code>0</code>. Поэтому, если разбирать элементы попарно, последняя пара остановится на <code>n - 2</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Сортировка выбором:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>для i от 0 до n-1
    найти наименьший элемент между i'ым и n-1'ым
    заменить наименьший i'ым элементом
</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Теперь мы строим сортированный список путем прохождения через неотсортированную часть списка, нахождения наименьшего элемента и помещения его в конец нашего отсортированного списка.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Сортировка вставками:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>для i от 1 до n-1
    назвать элементы от 0 до i-1 "сортированной частью"
    удалить i'ный элемент
    поместить его в отсортированную часть, соблюдая порядок</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Здесь мы строим сортированный список, беря каждый элемент списка и помещая его в нужное место отсортированного списка.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Мы можем использовать число проделанных шагов, представив их в виде единицы измерения эффективности выбранного алгоритма. На самом деле можно выбрать любую единицу измерения, для нас главное, чтобы все использовали одну и ту же терминологию (название).</p>
</li>
<li>
<p>В пузырьковой сортировке, если у нас есть список с <em>n</em> количеством элементов, мы бы сравнивали (<em>n</em> - 1) пары в первом же прохождении списка.</p>
</li>
<li>
<p>И, после первого прохождения, элемент с наибольшим числом оказался бы в самой правой стороне списка. Поэтому, проходясь второй раз по списку, нам нужно будет производить только (<em>n</em> - 2) сравнения.</p>
</li>
<li>
<p>В итоге у нас получится (<em>n</em> - 1) + (<em>n</em> - 2) + &#8230;&#8203; + 1 сравнений. Можно представить это выражение вот так: <em>n</em>(<em>n</em> - 1)/2. А если перемножить, то так: (<em>n</em><sup>2</sup> - <em>n</em>)/2.</p>
</li>
<li>
<p>Смотря на время выполнения программы, нас будет интересовать элемент наибольшей величины, так как только он и будет важен после того, как <em>n</em> будет иметь наибольшее значение. Можно избавиться даже от 1/2.</p>
</li>
<li>
<p>Мы можем разобрать пример (не доказательство!), который поможет нам лучше понять данное действие. Представим, что нам нужно отсортировать 1,000,000 чисел. Тогда пузырьковой сортировке понадобится 1,000,000<sup>2</sup>/2 - 1,000,000/2 шагов. И если мы развернем первое число, получим 500,000,000,000 - 500,000 = 499,999,500,000. Которое будет ужасно близко к значению изначального числа.</p>
</li>
<li>
<p>Поэтому, когда у нас есть выражение следующего вида (<em>n</em><sup>2</sup> - <em>n</em>)/2, мы можем сказать, что время выполнения алгоритма <em>O</em>(<em>n</em><sup>2</sup>).</p>
</li>

<li>
<p>В зависимости от используемого алгоритма время его выполнения может помечаться различными способами:</p>
<div class="ulist">
<ul>
<li>
<p><em>O</em>(<em>n</em><sup>2</sup>)</p>
</li>
<li>
<p><em>O</em>(<em>n</em> log <em>n</em>)</p>
</li>
<li>
<p><em>O</em>(<em>n</em>)</p>
</li>
<li>
<p><em>O</em>(log <em>n</em>)</p>
</li>
<li>
<p><em>O</em>(1)</p>
<div class="ulist">
<ul>
<li>
<p> <em>O</em>(1) означает, что потребуется один шаг, или 10 шагов, или строго заданное определенное число шагов для решения проблемы вне зависимости от ее размера.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Оказывается, если мы распишем все шаги, пузырьковая сортировка, сортировка вставками и сортировка выбором - у всех них скорость выполнения программы будет <em>O</em>(<em>n</em><sup>2</sup>). Хоть они и мало отличаются друг от друга, они все вовлечены в разнообразные методы прохождения через все <em>n</em> элементы до <em>n</em> количества раз. С сортировкой вставками мы просматриваем каждый элемент один раз, но дойдя до сортировки нам возможно придется смещать все элементы в списке, который мы уже отсортировали, а это дополнительная работа.</p>
</li>
<li>
<p>Нахождение элемента в неотсортированном списке используя например линейную сортировку, потребовало бы <em>O</em>(<em>n</em>) времени прохождения, т.к. нам нужно сперва просмотреть все элементы <em>n</em> до того, как мы найдем нужный нам элемент.</p>
</li>
<li>
<p>У бинарного поиска логарифмическая скорость выполнения работы <em>O</em>(log <em>n</em>), т.к. каждый раз мы сокращаем проблему в два раза.</p>
</li>
<li>
<p>И алгоритм постоянного времени прохождения будет записываться как <em>O</em>(1). К примеру сложение чисел или выведение чего-либо на экран. Поскольку можно сказать, что каждый из них требует только один шаг или действие.</p>
</li>
<li>
<p>Другой символ, который мы могли повстречать, это большая Омега <strong>Ω</strong>, которая является противоположностью большой O. Большая O - худшее время работы алгоритма. Если брать сортировку, то для многих алгоритмов обратно-отсортированный список будет худшим расположением элементов. А большая Омега - это нижайшая граница или лучший сценарий поведения алгоритма.</p>
</li>
<li>
<p>Сортировка выбором может иметь эффективность работы Ω(<em>n</em><sup>2</sup>). Даже если все элементы будут отсортированы, мы бы этого не узнали, т.к. нам нужно будет каждый раз проходить через весь список, чтобы быть уверенными, что мы выбрали наименьший элемент. Поэтому получается, что мы смотрим на <em>n</em><sup>2</sup> элементов.</p>
</li>
<li>
<p>Пузырьковая сортировка, с другой стороны, может иметь время прохождения Ω(<em>n</em>), т.к. при отсутствии смещений наш алгоритм завершает свою работу. После просмотра всех <em>n</em> элементов мы понимаем, что сортированный список был действительно отсортирован и завершаем работу.</p>
</li>
<li>
<p>Но мы понимаем, что невозможно сортировать список с количеством <em>n</em> элементов за Ω(log <em>n</em>) или Ω(1) время, т.к. нам необходимо как минимум посмотреть на все элементы <em>n</em>, дабы убедиться, что все они отсортированы.</p>
</li>
<li>
<p>Алгоритмы поиска, такие как линейный и бинарный, могут работать со скоростью Ω(1), так как в лучшем случае нам может повезти и мы найдем нужный нам элемент с первого раза.</p>
</li>
<li>
<p>Есть еще одно обозначение эффективности работы алгоритма - тета Θ, если скорость обработки алгоритма в худшем (O) и в лучшем (Ω) случаях совпадает.</p>
</li>
<li>
<p>Мы посмотрели на <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">эту визуализацию</a> того, как отличаются друг от друга алгоритмы сортировки. Вот еще одна <a href="http://cglab.ca/~morin/misc/sortalg/">визуализация</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sorting-2"><a class="link" href="#sorting-2">Сортировка</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Вспомните наш псевдокод для поиска Юсупова в телефонной книге:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code> 0   поднять телефонную книгу
 1   открыть по середине
 2   посмотреть на фамилии
 3   если «Юсупов» есть среди фамилий
 4       позвонить «Юсупову»
 5   иначе если «Юсупов» на первой половине
 6       открыть середину левой части книги
 7       вернуться к 2 шагу
 8   иначе если «Юсупов» на второй половине
 9       открыть середину правой части книги
10       вернуться к 2 шагу
11   иначе
12       остановить программу</code></pre>
</div>
</div>
</li>
<li>
<p> В той версии мы использовали <code>вернуться к</code> для создания циклов в нашем алгоритме. Но все можно сделать гораздо проще:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code> 0   поднять телефонную книгу
 1   открыть по середине
 2   посмотреть на фамилии
 3   если «Юсупов» есть среди фамилий
 4       позвонить «Юсупову»
 5   иначе если «Юсупов» на первой половине
 6       искать "Юсупова" в левой части книги
 7       
 8   иначе если «Юсупов» на второй половине
 9       искать "Юсупова" в правой части книги
10       
11   иначе
12       остановить программу</code></pre>
</div>
</div>
</li>
<li>
<p>Теперь у нас рекурсивная программа, т.е. она будет вызывать саму себя.</p>
</li>
<li>
<p>Мы также можем написать псевдокод для сортировки слиянием:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>ввод n элементов
    если n &lt; 2
        вернуться
    иначе
        сортировать левую половину элементов
        сортировать правую половину элементов
        соединить отсортированные половины</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Если у нас меньше 2 элементов, то это значит, что наш список отсортирован, поэтому мы остановимся.</p>
</li>
<li>
<p>Теперь мы используем ту же самую функцию, чтобы она отсортировала для нас половинки, и, как только она их отсортирует, мы произведем слияние (соединение) этих половинок.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Короче, посмотрите на этот пример для лучшего представления:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>4 8 6 2 1 7 5 3        // неотсортированный список</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>| 4 8 6 2 | 1 7 5 3    // остортировать левую половину</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>| 4 8 | 6 2 1 7 5 3    // отсортировать левую половину левой части</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>| 4 | 8 6 2 1 7 5 3    // отсортировать левую половину левой части первой левой половины, т.е. только 4-ку. Одно число по-любому является отсортированным (в данной крайней левой половине другого числа просто нет), т.е. эта половина отсортирована. </code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>4 | 8 | 6 2 1 7 5 3    // отсортировать правую половину левой части левой половины, т.е. только 8-ку. Поэтому же принципу данная половина тоже отсортирована.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>| _ _ | 6 2 1 7 5 3    // теперь мы производим слияние (соединение) левой половины левой части
| 4 8 |                // подключаем дополнительную память для хранения сортированного списка с размером 2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | 6 2 | 1 7 5 3    // теперь мы возвращаемся и сортируем правую половину левой части
4 8 | 2 6 |            // отсортировали правую половину левой части</code></pre>
</div>
</div>
</li>
<li>
<p>Теперь мы можем вспомнить, что наше второе предыдущее выражение, "отсортировать левую половину"  завершается с помощью слияния двух отсортированных половин:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | 6 2 | 1 7 5 3
4 8 | 2 6 |
2 4   6 8 |            // соединенная левая половина</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Чтобы произвести слияние двух отсортированных списков, мы начинаем с начала двух списков и на каждом шагу берем наименьший из представленных элементов.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Теперь повторим с правой половиной:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | _ _ | 1 7 5 3
_ _ | _ _ |
2 4   6 8 |</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | _ _ | 1 7 5 3
_ _ | _ _ | 1 7 |      // отсортированная левая половина правой части
2 4   6 8 |</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | _ _ | 1 7 5 3
_ _ | _ _ | 1 7 | 3 5 |  // отсортированная правая половина правой части
2 4   6 8 |</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | _ _ | 1 7 5 3
_ _ | _ _ | _ _ | _ _ |
2 4   6 8 | 1 3   5 7    // отсортированная правая половина</code></pre>
</div>
</div>
</li>
<li>
<p>Теперь мы вернулись к наашему первому прохождению алгоритма, где нам нужно произвести слияние двух половин:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>_ _ | _ _ | 1 7 5 3
_ _ | _ _ | _ _ | _ _ |
2 4   6 8 | 1 3   5 7
1 2   3 4   5 6   7 8    // соединенный список</code></pre>
</div>
</div>
</li>
<li>
<p>Похоже на то, что было произведено очень много шагов, плюс понадобилось подключить дополнительное пространство для хранения новых списков где-то в памяти.</p>
</li>
<li>
<p>Но, в процессе сортировки, мы могли бы использовать пространство нашего начального списка, чтобы произвести сортировку, выделяя память только для двух списков.</p>
</li>
<li>
<p>И со списком в 8 элементов нам бы понадобилось только 3 слоя, который трижды делил бы этот список.</p>
</li>
<li>
<p>Каждый раз деля проблему надвое мы привели нашу проблему, сократив ее, к чему-то логарифичному (вспомните пример нулевой недели "разделяй и властвуй"). На каждом слое мы смотрели на <em>n</em> элементы, дабы произвести их слияние. Чисто интуитивно можно предположить, что этому алгоритму требуется O(<em>n</em> log <em>n</em>) времени.</p>
</li>
<li>
<p> Можно даже посмотреть на псевдокод, чтобы проанализировать время выполнения программы (running time):</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>ввод n элементов
    если n &lt; 2
        вернуться
    иначе
        сортировать левую половину элементов
        сортировать правую половину элементов
        соединить отсортированные половины</code></pre>
</div>
</div>
</li>
<li>
<p>Первому условию требуется совершить O(1) шаг для возврата или выхода из функции. Это постоянное число, поэтому T(<em>n</em>) = O(1). Время выполнения программы равно O(1).</p>
</li>
<li>
<p>Но второму условию требуется T(<em>n</em>) = T(<em>n</em>/2) + T(<em>n</em>/2) + O(<em>n</em>), т.к. сортировка каждой половины элементов требует половины времени, затрачиваемого на сортировку всех элементов, плюс время, требующееся на слияние двух половин.</p>
</li>

<li>
<p>Давайте посмотрим, как это может быть использовано.</p>
</li>
<li>
<p><code>sigma0.c</code> (сигма):</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;cs50.h&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;stdio.h&gt;</span><span class="tok-cp"></span>

<span class="tok-kt">int</span> <span class="tok-nf">sigma</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">m</span><span class="tok-p">);</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-kt">int</span> <span class="tok-n">n</span><span class="tok-p">;</span>
    <span class="tok-k">do</span>
    <span class="tok-p">{</span>
        <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;Введите положительный integer: &quot;</span><span class="tok-p">);</span>
        <span class="tok-n">n</span> <span class="tok-o">=</span> <span class="tok-n">get_int</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">n</span> <span class="tok-o">&lt;</span> <span class="tok-mi">1</span><span class="tok-p">);</span>

    <span class="tok-kt">int</span> <span class="tok-n">answer</span> <span class="tok-o">=</span> <span class="tok-n">sigma</span><span class="tok-p">(</span><span class="tok-n">n</span><span class="tok-p">);</span>

    <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%i</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">answer</span><span class="tok-p">);</span>
<span class="tok-p">}</span>

<span class="tok-kt">int</span> <span class="tok-nf">sigma</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">m</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-kt">int</span> <span class="tok-n">sum</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;=</span> <span class="tok-n">m</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">sum</span> <span class="tok-o">+=</span> <span class="tok-n">i</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-n">sum</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Эта программа (а точнее функция <code>int sigma(int m)</code> ) на входе принимает integer <code>m</code> (надеюсь, вы уже понимаете концепции входа и выхода) и к нему добавляются все числа от <code>1</code> до <code>m</code> включительно, с помощью цикла.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Версия <code>sigma1.c</code> с использованием рекурсии будет выглядить вот так:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;cs50.h&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;stdio.h&gt;</span><span class="tok-cp"></span>

<span class="tok-kt">int</span> <span class="tok-nf">sigma</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">m</span><span class="tok-p">);</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-kt">int</span> <span class="tok-n">n</span><span class="tok-p">;</span>
    <span class="tok-k">do</span>
    <span class="tok-p">{</span>
        <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;Введите положительный integer: &quot;</span><span class="tok-p">);</span>
        <span class="tok-n">n</span> <span class="tok-o">=</span> <span class="tok-n">get_int</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">n</span> <span class="tok-o">&lt;</span> <span class="tok-mi">1</span><span class="tok-p">);</span>

    <span class="tok-kt">int</span> <span class="tok-n">answer</span> <span class="tok-o">=</span> <span class="tok-n">sigma</span><span class="tok-p">(</span><span class="tok-n">n</span><span class="tok-p">);</span>

    <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%i</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">answer</span><span class="tok-p">);</span>
<span class="tok-p">}</span>

<span class="tok-kt">int</span> <span class="tok-nf">sigma</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">m</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">m</span> <span class="tok-o">&lt;=</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-k">else</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-p">(</span><span class="tok-n">m</span> <span class="tok-o">+</span> <span class="tok-n">sigma</span><span class="tok-p">(</span><span class="tok-n">m</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-p">));</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Функция <code>sigma</code> вызывает саму себя, добавляя при этом текущую <code>m</code> к тому, что вернет сумма, а именно от <code>0</code> (потому что функция возвратит <code>0</code>, если <code>m</code> будет <code>0</code> или меньше) до <code>m - 1</code>, и это дает нам сумму от <code>0</code> до <code>m</code>.</p>
</li>
<li>
<p>Но, хотя рекурсия и может приятно выглядеть, ее применение не всегда может быть правильным выбором, т.к. если у <code>m</code> будет слишком большое значение, придется снова и снова вызывать функцию, заполняя все больше памяти.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Скоро мы разберем более привлекательные структуры данных и то, как мы можем применить к ним все разобранные нами на этой неделе концепции.</p>
</li>
</ul>
</div>
</div>
</div>
            </div>
        </div>
